
"""
    expectedemissions(model; nsamples=100)

Compute the probability of a right choice and the expected spike rate

The emissions consist of the behavioral choice in each trial and the spike train response of each neuron at each time step of each trial. The behavioral choice is modelled as a Bernoulli random variable, and the spike train response is modelled as a Poisson random variable. Here we compute the expectated value of these random variablees by averaging across samples of the model.

ARGUMENT
- a structure containing information for a factorial hidden Markov drift-diffusion model

OPTION ARGUMENT
-`nsamples`: number of samples over which the expectation is taken

RETURN
-`ŒªŒît`: expectd value of the number of spikes per `Œît` at each time step. Element ŒªŒît[i][n][t] corresponds to the t-timestep and the n-th neuron in the i-th trialset
-`pchoice`: estimate of the mean of the probability of a right. Element pchoice[i][m] corresponds to the m-th trial in the i-th trialset

EXAMPLE
```julia-repl
julia> using FHMDDM
julia> datapath = "/mnt/cup/labs/brody/tzluo/analysis_data/analysis_2022_07_29a_test/T176_2018_05_03/data.mat"
julia> model = Model(datapath)
julia> ŒªŒît, pchoice = expectedemissions(model; nsamples=2)
julia> save(ŒªŒît, model, pchoice; filename="postinitialization.mat")
julia>
```
"""
function expectedemissions(model::Model; nsamples::Integer=100)
    @unpack trialsets, options, Œ∏native = model
    pchoice = map(trialset->zeros(trialset.ntrials), trialsets)
    ŒªŒît = map(trialsets) do trialset
			map(trialset.mpGLMs) do mpGLM
				zeros(trialset.ntimesteps)
			end
		  end
	memory = Memoryforgradient(model)
	P = update!(memory, model, concatenateparameters(model)[1])
    for i in eachindex(trialsets)
        for s = 1:nsamples
			sampledtrials =	collect(sample!(memory, P, Œ∏native, trial) for trial in trialsets[i].trials)
			for m in eachindex(sampledtrials)
				pchoice[i][m] += sampledtrials[m].choice
			end
            for n in eachindex(trialsets[i].mpGLMs)
				ŒªŒît[i][n] .+= sampleemissions(trialsets[i].mpGLMs[n], sampledtrials)
            end
        end
    	pchoice[i] ./= nsamples
        for n in eachindex(ŒªŒît[i])
            ŒªŒît[i][n] ./= nsamples
        end
    end
    return ŒªŒît, pchoice
end

"""
    sample!(memory, P, Œ∏native, trial)

Sample the latent variables and behavioral choice for one trial

ARGUMENT
-`Œ∏native`: model parameters in their native space
-`trial`: stucture containing the stimulus information of one trial being used for sampling

RETURN
-an instance of `Trial` containing the generated behavioral choice as well as the sequence of latent variables
"""
function sample!(memory::Memoryforgradient, P::Probabilityvector, Œ∏native::LatentŒ∏, trial::Trial)
    @unpack A·µÉinput, A·µÉsilent, A·∂ú, œÄ·∂ú, Œû = memory
	c = samplecoupling(A·∂ú, trial.ntimesteps, œÄ·∂ú)
    a = sampleaccumulator(A·µÉinput, A·µÉsilent, P, Œ∏native, trial)
	zeroindex = cld(Œû,2)
	if a[end] < zeroindex
		p_right_choice = Œ∏native.œà[1]/2
	elseif a[end] == zeroindex
		p_right_choice = 0.5
	else
		p_right_choice = 1-Œ∏native.œà[1]/2
	end
	choice = rand() < p_right_choice
    Trial(	clicks=trial.clicks,
          	choice=choice,
			movementtime_s=trial.movementtime_s,
		  	ntimesteps=trial.ntimesteps,
			previousanswer=trial.previousanswer,
			a=a,
			c=c)
end

"""
	sampleaccumulator(A·µÉinput, A·µÉsilent, P, Œ∏native, trial)

Sample the values of the accumulator variable in one trial

ARGUMENT
-`A·µÉinput`: memory for computing the transition matrix during a timestep with stimulus input
-`A·µÉsilent`: transition matrix during a timestep without stimulus input
-`P`: memory for computing the prior probability or transition matrix
-`Œ∏native`: parameters controlling the latent variables in native space
-`trial`: a structure containing information on the trial being considered

RETURN
-`a`: a vector containing the sample value of the coupling variable in each time step
"""
function sampleaccumulator(A·µÉinput::Vector{<:Matrix{<:Real}}, A·µÉsilent::Matrix{<:Real}, P::Probabilityvector, Œ∏native::LatentŒ∏, trial::Trial)
	@unpack clicks, ntimesteps, previousanswer,
	a = zeros(Int, ntimesteps)
	priorprobability!(P, previousanswer)
	a[1] = findfirst(rand() .< cumsum(P.ùõë))
	if length(clicks.time) > 0
		adaptedclicks = adapt(clicks, Œ∏native.k[1], Œ∏native.œï[1])
	end
	for t = 2:ntimesteps
		if isempty(clicks.inputindex[t])
			A·µÉ = A·µÉsilent
		else
			A·µÉ = A·µÉinput[clicks.inputindex[t][1]]
			update_for_transition_probabilities!(P, adaptedclicks, clicks, t)
			transitionmatrix!(A·µÉ, P)
		end
		pùêö = A·µÉ[:,a[t-1]]
		a[t] = findfirst(rand() .< cumsum(pùêö))
	end
	return a
end

"""
	samplecoupling(A·∂ú, ntimesteps, œÄ·∂ú)

Sample the values of the coupling variable in one trial

ARGUMENT
-`A·∂ú`: transition matrix of the coupling variable
-`ntimesteps`: number of time steps in the trial
-`œÄ·∂ú`: prior probability of the coupling variable

RETURN
-`c`: a vector containing the sample value of the coupling variable in each time step
"""
function samplecoupling(A·∂ú::Matrix{<:Real}, ntimesteps::Integer, œÄ·∂ú::Vector{<:Real})
	if length(œÄ·∂ú) == 1
		return ones(Int, ntimesteps)
	else
		c = zeros(Int, ntimesteps)
		cumulativepùêú = cumsum(œÄ·∂ú)
	    c[1] = findfirst(rand() .< cumulativepùêú)
		cumulativeA·∂ú = cumsum(A·∂ú, dims=1)
	    for t = 2:ntimesteps
	        cumulativepùêú = cumulativeA·∂ú[:,c[t-1]]
	        c[t] = findfirst(rand() .< cumulativepùêú)
	    end
		return c
	end
end

"""
	sampleemissions(mpGLM, trials)

Generate one sample from the mixture of Poisson generalized linear model (GLM) of a neuron

ARGUMENT
-`mpGLM`: the fitted mixture of Poisson GLM of a neuron
-`trials`: a vector of structures, one of which contains the generated states of the accumulator and coupling variable of one trial

RETURN
-`ùê≤ÃÇ`: a sample of the spike train response for each timestep
"""
function sampleemissions(mpGLM::MixturePoissonGLM, trials::Vector{<:Trial})
	@unpack Œît, Œ¶‚Çï, ùêó, ùêï, ùê≤ = mpGLM
	@unpack ùê†, ùêÆ, ùêØ = mpGLM.Œ∏
	ùõö = transformaccumulator(mpGLM)
	max_spikehistory_lag, n_spikehistory_parameters = size(Œ¶‚Çï)
	ùê° = Œ¶‚Çï*ùêÆ[1:n_spikehistory_parameters]
	ùêû = ùêÆ[n_spikehistory_parameters+1:end]
	indices_time_move_in_ùêó = 1+n_spikehistory_parameters .+ (1:length(ùêû))
	ùêÑ = @view ùêó[:,indices_time_move_in_ùêó]
	ùêÑùêû = ùêÑ*ùêû
	Kùê† = length(ùê†)
	KùêØ = length(ùêØ)
	Œû = length(ùõö)
	max_spikes_per_step = floor(1000Œît)
    ùê≤ÃÇ = similar(ùê≤)
    œÑ = 0
    for m in eachindex(trials)
        for t = 1:trials[m].ntimesteps
            œÑ += 1
            j = trials[m].a[t]
            k = trials[m].c[t]
			g‚Çñ = ùê†[min(k, Kùê†)]
			ùêØ‚Çñ = ùêØ[min(k, KùêØ)]
			L = g‚Çñ + ùêÑùêû[œÑ]
			for i in eachindex(ùêØ‚Çñ)
				L+= ùõö[j]*ùêï[œÑ,i]*ùêØ‚Çñ[i]
			end
			for lag = 1:min(max_spikehistory_lag, t-1)
				if ùê≤ÃÇ[œÑ-lag] > 0
					L += ùê°[lag]*ùê≤ÃÇ[œÑ-lag]
				end
			end
            Œª = softplus(L)
            ùê≤ÃÇ[œÑ] = min(rand(Poisson(Œª*Œît)), max_spikes_per_step)
        end
    end
	return ùê≤ÃÇ
end

"""
	sample_and_save(model)

Generate samples of a model and save

ARGUMENT
-`model`: an instance of the factorial-hidden Markov drift-diffusion model

OPTIONAL ARGUMENT
-`datafilename`: name of the file containing the generated data
-`resultsfilename`: name of the file to which fitted results will be saved
-`nsamples`: number of samples to generate

EXAMPLE
```julia-repl
julia> using FHMDDM
julia> datapath = "/mnt/cup/labs/brody/tzluo/analysis_data/analysis_2022_07_06a_test/T176_2018_05_03_b5K1K1/data.mat"
julia> model = Model(datapath)
julia> FHMDDM.sample_and_save(model;nsamples=2)
julia> newmodel = Model(dirname(datapath)*"/sample1.mat")
julia>

julia> using FHMDDM
julia> datapath = "/mnt/cup/labs/brody/tzluo/analysis_data/analysis_2022_07_08e_pr/T274_2020_12_14/sample10.mat"
julia> newmodel = Model(datapath)
julia>
```
"""
function sample_and_save(model::Model; datafilename::String="sample", nsamples::Integer=10, resultsfilename::String="results")
	folderpath = dirname(model.options.datapath)
	optionsdict = dictionary(model.options)
	pad = length(string(nsamples))
	samplepaths, resultpaths = fill("", nsamples), fill("", nsamples)
	samplepaths = open(folderpath*"/samplepaths.txt", "w")
	resultpaths = open(folderpath*"/resultpaths.txt", "w")
	for i = 1:nsamples
		sampleindex = string(i, pad=pad)
	    optionsdict["datapath"] = folderpath*"/"*datafilename*sampleindex*".mat"
	    optionsdict["resultspath"] = folderpath*"/"*datafilename*sampleindex*"_"*resultsfilename*".mat"
		if i > 1
			write(samplepaths, "\n")
			write(resultpaths, "\n")
		end
		write(samplepaths, optionsdict["datapath"])
		write(resultpaths, optionsdict["resultspath"])
		trialsets = sample(model)
		save(optionsdict, trialsets)
	end
	close(samplepaths)
	close(resultpaths)
end

"""
    sample(mpGLM, sampledtrials)

Generate one sample from the mixture of Poisson generalized linear model (GLM) of a neuron

ARGUMENT
-`mpGLM`: the fitted mixture of Poisson GLM of a neuron
-`sampledtrials`: a vector of structures, one of which contains the generated states of the accumulator and coupling variable of one trial

RETURN
-`mpGLM`: a sample of the mixture of Poisson GLM
"""
function sample(mpGLM::MixturePoissonGLM, sampledtrials::Vector{<:Trial})
    ùê≤ÃÇ = sampleemissions(mpGLM, sampledtrials)
	Œ∏ = GLMŒ∏(b = copy(mpGLM.Œ∏.b),
			b_scalefactor = mpGLM.Œ∏.b_scalefactor,
			ùê† = copy(mpGLM.Œ∏.ùê†),
			ùêÆ = copy(mpGLM.Œ∏.ùêÆ),
			ùêØ = map(ùêØ‚Çñ->copy(ùêØ‚Çñ), mpGLM.Œ∏.ùêØ))
    MixturePoissonGLM(Œît=mpGLM.Œît,
                      dùõè_dB=mpGLM.dùõè_dB,
					  Œ¶‚Çê=mpGLM.Œ¶‚Çê,
					  Œ¶‚Çï=mpGLM.Œ¶‚Çï,
					  Œ¶‚Çò=mpGLM.Œ¶‚Çò,
					  Œ¶‚Çú=mpGLM.Œ¶‚Çú,
					  Œ∏=Œ∏,
                      ùêï=mpGLM.ùêï,
                      ùêó=mpGLM.ùêó,
                      ùê≤=ùê≤ÃÇ)
end
